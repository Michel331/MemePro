{% extends 'meme/base.html' %}
{% load static %}

{% block title %}Créer un Mème - MèmePro{% endblock %}

{% block content %}
<style>
    /* Styles spécifiques à la page de création */
    .meme-editor-layout {
        display: flex;
        flex-wrap: wrap; /* Permet de passer en colonne sur petits écrans */
        gap: 30px; /* Espace entre le formulaire et l'aperçu */
        align-items: flex-start; /* Aligner les éléments en haut */
    }

    .meme-form-column {
        flex: 1; /* Prend l'espace disponible */
        min-width: 300px; /* Largeur minimale avant de passer en colonne */
    }

    .meme-preview-column {
        flex: 1.5; /* Donne un peu plus d'espace à l'aperçu */
        min-width: 320px; /* Largeur minimale */
        display: flex; /* Pour centrer le canvas à l'intérieur si besoin */
        justify-content: center;
    }

    #meme-preview-container {
        position: relative;
        width: fit-content; 
        max-width: 100%; /* Important pour le responsive */
        margin: 0; /* Retiré le margin auto, géré par flex maintenant */
        border: 2px dashed var(--secondary-color, #ccc);
        padding: 10px;
        background-color: #f9f9f9;
        border-radius: var(--border-radius);
    }
    #meme-canvas {
        display: block;
        max-width: 100%; /* S'adapte au conteneur #meme-preview-container */
        height: auto;
        background-color: #fff;
    }
    #original-image-preview {
        display: none; 
    }
    /* Ajustements pour le select de police */
    .form-group select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        background-color: white;
        font-size: 1em;
    }
    /* Media query pour la disposition en colonne sur petits écrans */
    @media (max-width: 768px) {
        .meme-editor-layout {
            flex-direction: column-reverse; /* Aperçu en haut, formulaire en bas */
            align-items: center; /* Centre les éléments en mode colonne */
        }
        .meme-form-column,
        .meme-preview-column {
            flex-basis: 100%; /* Chaque colonne prend toute la largeur */
            width: 100%;
            max-width: 550px; /* Limite la largeur en mode colonne */
        }
        #meme-preview-container {
            margin-bottom: 30px; /* Espace après l'aperçu */
        }
    }
</style>

<h1>Créer un Mème</h1>

<div class="meme-editor-layout">
    <div class="meme-form-column">
        <form method="post" enctype="multipart/form-data" id="meme-form" class="form-styled">
            {% csrf_token %}
            <div class="form-group">
                <label for="original_image_input">Image :</label>
                <input type="file" name="original_image" id="original_image_input" required accept="image/*">
            </div>
            <div class="form-group">
                <label for="top_text_input">Texte haut :</label>
                <input type="text" name="top_text" id="top_text_input" value="{{ top_text|default:'' }}">
            </div>
            <div class="form-group">
                <label for="bottom_text_input">Texte bas :</label>
                <input type="text" name="bottom_text" id="bottom_text_input" value="{{ bottom_text|default:'' }}">
            </div>
            {% if fonts %}
            <div class="form-group font-selector-group">
                <label for="font_selection_input">Police :</label>
                <select name="font_selection" id="font_selection_input">
                    {% for font in fonts %}
                        <option value="{{ font.file }}" {% if font.file == selected_font %}selected{% endif %}>{{ font.name }}</option>
                    {% endfor %}
                </select>
            </div>
            {% endif %}
            <div class="form-actions">
                <button type="submit" class="btn btn-primary">Générer le Mème</button>
            </div>
        </form>
    </div>

    <div class="meme-preview-column">
        <div id="meme-preview-container">
            <img id="original-image-preview" src="#" alt="Aperçu de l'image originale">
            <canvas id="meme-canvas"></canvas>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
    // --- Références aux éléments du DOM --- //
    const canvas = document.getElementById('meme-canvas');
    const ctx = canvas.getContext('2d');
    const originalImageInput = document.getElementById('original_image_input');
    const topTextInput = document.getElementById('top_text_input');
    const bottomTextInput = document.getElementById('bottom_text_input');
    const fontSelectionInput = document.getElementById('font_selection_input');
    const memeForm = document.getElementById('meme-form');
    // L'élément <img> est utilisé pour charger l'image avant de la dessiner sur le canvas
    const tempImage = new Image(); 

    // --- Constantes de configuration pour le dessin --- //
    const CANVAS_MAX_WIDTH_PREVIEW = 500; // Largeur max de l'image dans l'aperçu
    const DEFAULT_FONT_FAMILY_CANVAS = 'Arial'; // Police de secours pour le canvas
    const TEXT_COLOR_CANVAS = 'white';
    const TEXT_OUTLINE_COLOR_CANVAS = 'black';

    // --- Fonctions de dessin sur le Canvas --- //

    /**
     * Efface le canvas et affiche un message si aucune image n'est chargée.
     */
    function initializeOrClearCanvas(message = "Chargez une image") {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!tempImage.src || tempImage.naturalWidth === 0) {
            // Si le canvas n'a pas de dimensions, lui en donner des initiales
            if (canvas.width === 0 || canvas.height === 0) {
                const previewContainer = document.getElementById('meme-preview-container');
                const containerWidth = previewContainer.offsetWidth > 0 ? previewContainer.offsetWidth - 20 : CANVAS_MAX_WIDTH_PREVIEW; // -20 pour padding
                canvas.width = containerWidth;
                canvas.height = canvas.width * (3/4); // Ratio 4:3 par défaut
            }
            ctx.font = "20px " + DEFAULT_FONT_FAMILY_CANVAS;
            ctx.textAlign = "center";
            ctx.fillStyle = "#aaa";
            ctx.fillText(message, canvas.width / 2, canvas.height / 2);
        }
    }

    /**
     * Dessine l'image de fond sur le canvas, en l'ajustant à la taille du canvas.
     */
    function drawBackgroundImageOnCanvas() {
        if (tempImage.src && tempImage.complete && tempImage.naturalWidth > 0) {
            ctx.drawImage(tempImage, 0, 0, canvas.width, canvas.height);
        }
    }

    /**
     * Dessine un bloc de texte (avec contour) sur le canvas.
     * @param {string} text - Le texte à dessiner.
     * @param {number} yPosition - La coordonnée Y pour le texte.
     * @param {string} selectedFontName - Le nom de la police à utiliser.
     * @param {number} baseFontSize - La taille de base de la police.
     */
    function drawTextBloc(text, yPosition, selectedFontName, baseFontSize) {
        if (!text) return;

        const xPosition = canvas.width / 2;
        // S'assurer que la police sélectionnée est bien entre guillemets si elle contient des espaces
        const fontNameForContext = selectedFontName.includes(' ') ? `"${selectedFontName}"` : selectedFontName;

        ctx.font = `bold ${baseFontSize}px ${fontNameForContext}, Impact, ${DEFAULT_FONT_FAMILY_CANVAS}`;
        ctx.textAlign = 'center';
        ctx.lineJoin = 'round'; // Pour des angles de contour plus doux
        
        // Contour
        ctx.lineWidth = Math.max(1, baseFontSize * 0.08); // Épaisseur relative au texte
        ctx.strokeStyle = TEXT_OUTLINE_COLOR_CANVAS;
        ctx.strokeText(text.toUpperCase(), xPosition, yPosition);

        // Texte principal
        ctx.fillStyle = TEXT_COLOR_CANVAS;
        ctx.fillText(text.toUpperCase(), xPosition, yPosition);
    }

    /**
     * Fonction principale pour redessiner tout le mème sur le canvas.
     */
    function redrawMemeCanvas() {
        initializeOrClearCanvas(); // Efface et prépare le canvas
        if (!tempImage.src || tempImage.naturalWidth === 0) return; // Sortir si pas d'image

        drawBackgroundImageOnCanvas(); // Dessine l'image de fond

        // Paramètres pour le texte
        const selectedFontName = fontSelectionInput ? fontSelectionInput.selectedOptions[0].text : 'Cabilla';
        const baseFontSize = Math.max(12, canvas.height * 0.08); // Taille de police relative à la hauteur du canvas
        const textMarginFromEdge = canvas.height * 0.05; // Marge de 5% par rapport aux bords haut/bas
        
        // Calcul des positions Y pour les textes
        // Pour le texte du haut: marge + hauteur approximative de la police
        const yTop = textMarginFromEdge + (baseFontSize * 0.8); 
        // Pour le texte du bas: hauteur du canvas - marge
        const yBottom = canvas.height - textMarginFromEdge;

        drawTextBloc(topTextInput.value, yTop, selectedFontName, baseFontSize);
        drawTextBloc(bottomTextInput.value, yBottom, selectedFontName, baseFontSize);
    }

    // --- Gestionnaires d'Événements --- //

    /**
     * Se déclenche quand une image est chargée dans l'élément <img id="tempImage">
     */
    tempImage.onload = () => {
        // Ajuster les dimensions du canvas à l'image chargée, en respectant une largeur max
        const previewContainer = document.getElementById('meme-preview-container');
        const containerEffectiveMaxWidth = previewContainer.offsetWidth > 0 ? previewContainer.offsetWidth - 20 : CANVAS_MAX_WIDTH_PREVIEW;

        let displayWidth = tempImage.naturalWidth;
        let displayHeight = tempImage.naturalHeight;

        if (displayWidth > containerEffectiveMaxWidth) {
            displayHeight = (containerEffectiveMaxWidth / displayWidth) * displayHeight;
            displayWidth = containerEffectiveMaxWidth;
        }
        
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width = displayWidth;
            canvas.height = displayHeight;
        }
        redrawMemeCanvas(); // Redessiner avec la nouvelle image
    };
    tempImage.onerror = () => {
        console.error("Erreur de chargement de l'image pour l'aperçu.");
        initializeOrClearCanvas("Erreur image");
    }

    /**
     * Se déclenche quand l'utilisateur choisit un fichier image.
     */
    originalImageInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                // Charger l'image dans notre élément <img> temporaire
                // Cela déclenchera tempImage.onload une fois l'image chargée
                tempImage.src = e.target.result;
            }
            reader.onerror = () => {
                console.error("Erreur de lecture du fichier image.");
                initializeOrClearCanvas("Erreur fichier");
            }
            reader.readAsDataURL(file);
        } else {
            // Si aucun fichier n'est sélectionné (par ex. l'utilisateur annule)
            tempImage.src = ""; // Réinitialiser l'image temporaire
            initializeOrClearCanvas(); // Afficher le message par défaut
        }
    });

    // Redessiner le mème quand les textes ou la police changent
    topTextInput.addEventListener('input', redrawMemeCanvas);
    bottomTextInput.addEventListener('input', redrawMemeCanvas);
    if (fontSelectionInput) {
        fontSelectionInput.addEventListener('change', redrawMemeCanvas);
    }

    /**
     * Validation du formulaire avant soumission.
     */
    memeForm.addEventListener('submit', function(event) {
        const topText = topTextInput.value.trim();
        const bottomText = bottomTextInput.value.trim();
        if (!topText && !bottomText) {
            event.preventDefault(); // Empêche la soumission
            alert('Veuillez remplir au moins un champ de texte (haut ou bas) pour le mème.');
            if (!topText) topTextInput.focus(); else bottomTextInput.focus();
        }
        // S'assurer que le select de police est actif pour la soumission (au cas où il serait désactivé)
        if (fontSelectionInput && fontSelectionInput.disabled) {
            fontSelectionInput.disabled = false;
        }
    });

    // --- Initialisation au chargement de la page --- //
    window.addEventListener('DOMContentLoaded', () => {
        initializeOrClearCanvas(); // Affiche "Chargez une image" au début
    });

</script>
{% endblock %} 